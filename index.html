<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>Dual Monitor Cropper</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            background-color: #000;
            color: #fff;
            padding: 20px;
        }

        h3 {
            margin-bottom: 20px;
            font-size: 24px;
        }

        label {
            display: inline-block;
            margin-right: 10px;
            font-weight: bold;
        }

        input[type="file"],
        input[type="number"],
        input[type="range"] {
            background-color: #222;
            color: #fff;
            border: 1px solid #444;
            padding: 5px;
            margin: 5px 0;
        }

        input[type="number"] {
            width: 80px;
        }

        input[type="range"] {
            vertical-align: middle;
        }

        button {
            background-color: #333;
            color: #fff;
            border: 1px solid #555;
            padding: 8px 16px;
            margin: 5px 5px 5px 0;
            cursor: pointer;
            font-size: 14px;
        }

        button:hover {
            background-color: #444;
        }

        button:active {
            background-color: #222;
        }

        #canvas-container {
            position: relative;
            display: inline-block;
            border: 1px solid #444;
            margin-top: 20px;
            background-color: #111;
        }

        #preview {
            display: block;
            max-width: 100%;
        }

        .monitor-outline {
            position: absolute;
            border: 2px solid #fff;
            cursor: move;
            box-sizing: border-box;
        }

        #output {
            margin-top: 20px;
        }

        #output a {
            color: #fff;
            background-color: #333;
            padding: 8px 12px;
            text-decoration: none;
            border: 1px solid #555;
            margin: 5px 0;
        }

        #output a:hover {
            background-color: #444;
        }

        #scaleVal {
            display: inline-block;
            margin-left: 10px;
            font-weight: bold;
        }
    </style>
</head>

<body>
    <h3>Dual Monitor Cropper</h3>
    <input type="file" id="file">
    <br><br>
    <label>Monitor 1: </label>
    W <input id="m1w" type="number" value="1920" style="width:80px;">
    H <input id="m1h" type="number" value="1080" style="width:80px;">
    <br>
    <label>Monitor 2: </label>
    W <input id="m2w" type="number" value="1920" style="width:80px;">
    H <input id="m2h" type="number" value="1080" style="width:80px;">
    <br><br>
    <label>Scale: </label>
    
    <input id="scale" type="range" min="0.1" max="1" step="0.01" value="1">
    <span id="scaleVal">1.00</span>
    <button id="autoScale">Auto-scale</button>
    <br><br>
    <button id="load">Load
        Image</button>
        <button id="applyCrop">Crop & Download</button>
    <div id="output"></div>
    <script>
        const file = document.getElementById('file');
        const loadBtn = document.getElementById('load');
        const autoBtn = document.getElementById('autoScale');
        const output = document.getElementById('output');
        const scaleSlider = document.getElementById('scale');
        const scaleVal = document.getElementById('scaleVal');
        const m1wEl = document.getElementById('m1w');
        const m1hEl = document.getElementById('m1h');
        const m2wEl = document.getElementById('m2w');
        const m2hEl = document.getElementById('m2h');

        let img,
            container,
            preview,
            outlines = [];
        let scale = 1;

        scaleSlider.oninput = () => {
            scale = parseFloat(scaleSlider.value);
            scaleVal.textContent = scale.toFixed(2);
            drawOutlines();
        }

            ;

        loadBtn.onclick = () => {
            const f = file.files[0];
            if (!f) return alert("Select an image first!");
            const reader = new FileReader();

            reader.onload = e => {
                img = new Image();
                img.onload = setupPreview;
                img.src = e.target.result;
            }

                ;
            reader.readAsDataURL(f);
        }

            ;

        function setupPreview() {
            output.innerHTML = "";
            container = document.createElement('div');
            container.id = 'canvas-container';
            preview = document.createElement('canvas');
            preview.id = 'preview';
            preview.width = img.width;
            preview.height = img.height;
            container.appendChild(preview);
            output.appendChild(container);
            drawImage();
            createOutlines();
        }

        function drawImage() {
            const ctx = preview.getContext('2d');
            ctx.clearRect(0, 0, preview.width, preview.height);
            ctx.drawImage(img, 0, 0);
        }

        function createOutlines() {
            outlines.forEach(o => o.remove());
            outlines = [];

            const m1w = parseInt(m1wEl.value),
                m1h = parseInt(m1hEl.value);
            const m2w = parseInt(m2wEl.value),
                m2h = parseInt(m2hEl.value);

            const m1 = createMonitorOutline("m1", 0, 0, m1w, m1h);
            const m2 = createMonitorOutline("m2", m1w, 0, m2w, m2h);

            outlines.push(m1, m2);
            drawOutlines();
        }

        function drawOutlines() {
            outlines.forEach(o => {
                const w = parseFloat(o.dataset.w);
                const h = parseFloat(o.dataset.h);
                const x = parseFloat(o.dataset.x);
                const y = parseFloat(o.dataset.y);
                o.style.width = (w * scale) + "px";
                o.style.height = (h * scale) + "px";
                o.style.left = (x * scale) + "px";
                o.style.top = (y * scale) + "px";
            });
        }

        function createMonitorOutline(id, x, y, w, h) {
            const div = document.createElement('div');
            div.className = 'monitor-outline';
            div.dataset.id = id;
            div.dataset.x = x;
            div.dataset.y = y;
            div.dataset.w = w;
            div.dataset.h = h;
            makeDraggable(div);
            container.appendChild(div);
            return div;
        }

        function makeDraggable(el) {
            let offsetX,
                offsetY,
                dragging = false;

            el.addEventListener('mousedown', e => {
                dragging = true;
                const rect = container.getBoundingClientRect();
                const clickX = (e.clientX - rect.left) / scale;
                const clickY = (e.clientY - rect.top) / scale;
                offsetX = clickX - parseFloat(el.dataset.x);
                offsetY = clickY - parseFloat(el.dataset.y);
            });
            window.addEventListener('mouseup', () => dragging = false);

            window.addEventListener('mousemove', e => {
                if (!dragging) return;
                const rect = container.getBoundingClientRect();
                let x = (e.clientX - rect.left) / scale - offsetX;
                let y = (e.clientY - rect.top) / scale - offsetY;
                const w = parseFloat(el.dataset.w);
                const h = parseFloat(el.dataset.h);

                if (x + w > preview.width / scale) {
                    x = preview.width / scale - w;
                }

                if (y + h > preview.height / scale) {
                    y = preview.height / scale - h;
                }

                el.dataset.x = Math.max(0, x);
                el.dataset.y = Math.max(0, y);
                drawOutlines();
            });
        }

        autoBtn.onclick = () => {
            if (!img) return alert("Load an image first!");
            const m1w = parseInt(m1wEl.value),
                m1h = parseInt(m1hEl.value);
            const m2w = parseInt(m2wEl.value),
                m2h = parseInt(m2hEl.value);
            const totalW = m1w + m2w;
            const totalH = Math.max(m1h, m2h);
            const maxScale = Math.min(img.width / totalW,
                img.height / totalH);
            scale = maxScale;
            scaleSlider.value = scale.toFixed(2);
            scaleVal.textContent = scale.toFixed(2);
            drawOutlines();
        }

            ;

        document.getElementById('applyCrop').onclick = () => {
            if (!img) return;

            outlines.forEach(o => {
                const x = parseFloat(o.dataset.x) * scale;
                const y = parseFloat(o.dataset.y) * scale;
                const w = parseFloat(o.dataset.w) * scale;
                const h = parseFloat(o.dataset.h) * scale;

                const c = document.createElement('canvas');
                c.width = w;
                c.height = h;
                const ctx = c.getContext('2d');
                ctx.drawImage(img, x, y, w, h, 0, 0, w, h);

                const link = document.createElement('a');
                link.href = c.toDataURL('image/png');
                link.download = o.dataset.id + '.png';
                link.textContent = 'Download ' + o.dataset.id;
                link.style.display = 'block';
                output.appendChild(link);
            });
        }

            ;
    </script>
</body>

</html>
